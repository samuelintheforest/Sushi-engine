#pragma once
#ifndef RAWSRC
#define RAWSRC

#include "stb_image.h"

namespace Sushi {
    const stbi_uc fishIconRaw[] = {
      0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
      0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x08, 0x06, 0x00, 0x00, 0x00, 0xC3, 0x3E, 0x61,
      0xCB, 0x00, 0x00, 0x01, 0x85, 0x69, 0x43, 0x43, 0x50, 0x49, 0x43, 0x43, 0x20, 0x70, 0x72, 0x6F,
      0x66, 0x69, 0x6C, 0x65, 0x00, 0x00, 0x28, 0x91, 0x7D, 0x91, 0x3D, 0x48, 0xC3, 0x40, 0x1C, 0xC5,
      0x5F, 0x53, 0x45, 0x91, 0x8A, 0x48, 0x3B, 0x88, 0x38, 0x64, 0xA8, 0x0E, 0x62, 0x41, 0xAA, 0x88,
      0xA3, 0x54, 0xB1, 0x08, 0x16, 0x4A, 0x5B, 0xA1, 0x55, 0x07, 0x93, 0x4B, 0xBF, 0xA0, 0x49, 0x43,
      0x92, 0xE2, 0xE2, 0x28, 0xB8, 0x16, 0x1C, 0xFC, 0x58, 0xAC, 0x3A, 0xB8, 0x38, 0xEB, 0xEA, 0xE0,
      0x2A, 0x08, 0x82, 0x1F, 0x20, 0x8E, 0x4E, 0x4E, 0x8A, 0x2E, 0x52, 0xE2, 0xFF, 0x92, 0x42, 0x8B,
      0x18, 0x0F, 0x8E, 0xFB, 0xF1, 0xEE, 0xDE, 0xE3, 0xEE, 0x1D, 0x20, 0x34, 0x2A, 0x4C, 0x35, 0xBB,
      0x26, 0x01, 0x55, 0xB3, 0x8C, 0x54, 0x3C, 0x26, 0x66, 0x73, 0xAB, 0x62, 0xCF, 0x2B, 0x04, 0x04,
      0x31, 0x88, 0x28, 0xC6, 0x25, 0x66, 0xEA, 0x89, 0xF4, 0x62, 0x06, 0x9E, 0xE3, 0xEB, 0x1E, 0x3E,
      0xBE, 0xDE, 0x45, 0x78, 0x96, 0xF7, 0xB9, 0x3F, 0x47, 0xBF, 0x92, 0x37, 0x19, 0xE0, 0x13, 0x89,
      0xE7, 0x98, 0x6E, 0x58, 0xC4, 0x1B, 0xC4, 0x33, 0x9B, 0x96, 0xCE, 0x79, 0x9F, 0x38, 0xC4, 0x4A,
      0x92, 0x42, 0x7C, 0x4E, 0x3C, 0x61, 0xD0, 0x05, 0x89, 0x1F, 0xB9, 0x2E, 0xBB, 0xFC, 0xC6, 0xB9,
      0xE8, 0xB0, 0xC0, 0x33, 0x43, 0x46, 0x26, 0x35, 0x4F, 0x1C, 0x22, 0x16, 0x8B, 0x1D, 0x2C, 0x77,
      0x30, 0x2B, 0x19, 0x2A, 0xF1, 0x34, 0x71, 0x58, 0x51, 0x35, 0xCA, 0x17, 0xB2, 0x2E, 0x2B, 0x9C,
      0xB7, 0x38, 0xAB, 0x95, 0x1A, 0x6B, 0xDD, 0x93, 0xBF, 0x30, 0x90, 0xD7, 0x56, 0xD2, 0x5C, 0xA7,
      0x39, 0x82, 0x38, 0x96, 0x90, 0x40, 0x12, 0x22, 0x64, 0xD4, 0x50, 0x46, 0x05, 0x16, 0x22, 0xB4,
      0x6A, 0xA4, 0x98, 0x48, 0xD1, 0x7E, 0xCC, 0xC3, 0x3F, 0xEC, 0xF8, 0x93, 0xE4, 0x92, 0xC9, 0x55,
      0x06, 0x23, 0xC7, 0x02, 0xAA, 0x50, 0x21, 0x39, 0x7E, 0xF0, 0x3F, 0xF8, 0xDD, 0xAD, 0x59, 0x98,
      0x8A, 0xBA, 0x49, 0x81, 0x18, 0xD0, 0xFD, 0x62, 0xDB, 0x1F, 0xA3, 0x40, 0xCF, 0x2E, 0xD0, 0xAC,
      0xDB, 0xF6, 0xF7, 0xB1, 0x6D, 0x37, 0x4F, 0x00, 0xFF, 0x33, 0x70, 0xA5, 0xB5, 0xFD, 0xD5, 0x06,
      0x30, 0xFB, 0x49, 0x7A, 0xBD, 0xAD, 0x85, 0x8F, 0x80, 0x81, 0x6D, 0xE0, 0xE2, 0xBA, 0xAD, 0xC9,
      0x7B, 0xC0, 0xE5, 0x0E, 0x30, 0xF4, 0xA4, 0x4B, 0x86, 0xE4, 0x48, 0x7E, 0x9A, 0x42, 0xA1, 0x00,
      0xBC, 0x9F, 0xD1, 0x37, 0xE5, 0x80, 0xE0, 0x2D, 0xD0, 0xB7, 0xE6, 0xF6, 0xD6, 0xDA, 0xC7, 0xE9,
      0x03, 0x90, 0xA1, 0xAE, 0x96, 0x6F, 0x80, 0x83, 0x43, 0x60, 0xAC, 0x48, 0xD9, 0xEB, 0x1E, 0xEF,
      0xEE, 0xED, 0xEC, 0xED, 0xDF, 0x33, 0xAD, 0xFE, 0x7E, 0x00, 0xD3, 0xE2, 0x72, 0xCE, 0x65, 0xCC,
      0x08, 0x79, 0x00, 0x00, 0x00, 0x06, 0x62, 0x4B, 0x47, 0x44, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
      0xA0, 0xBD, 0xA7, 0x93, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0B, 0x12,
      0x00, 0x00, 0x0B, 0x12, 0x01, 0xD2, 0xDD, 0x7E, 0xFC, 0x00, 0x00, 0x00, 0x07, 0x74, 0x49, 0x4D,
      0x45, 0x07, 0xE6, 0x02, 0x13, 0x11, 0x3A, 0x32, 0xC4, 0x3F, 0xBF, 0x90, 0x00, 0x00, 0x02, 0x26,
      0x49, 0x44, 0x41, 0x54, 0x78, 0xDA, 0xED, 0xDD, 0xB1, 0x4D, 0xC3, 0x40, 0x18, 0x86, 0x61, 0x82,
      0x28, 0x58, 0x02, 0x89, 0x01, 0x3C, 0x04, 0x1B, 0x64, 0x06, 0x2A, 0xAA, 0x54, 0x48, 0x0C, 0x81,
      0x44, 0x95, 0x8A, 0x8A, 0x15, 0x48, 0x43, 0x45, 0xC1, 0x10, 0x69, 0x23, 0x21, 0x31, 0x04, 0x54,
      0x1C, 0x6D, 0x2A, 0x9F, 0xCC, 0xC7, 0xE1, 0x38, 0x7E, 0x9E, 0x36, 0x8A, 0x03, 0xD1, 0xAB, 0x3B,
      0xDD, 0x1F, 0x2B, 0x59, 0x94, 0x52, 0xCA, 0x09, 0xB3, 0x75, 0xEA, 0x2D, 0x10, 0x00, 0x02, 0x40,
      0x00, 0x08, 0x00, 0x01, 0x20, 0x00, 0xE6, 0xE4, 0x6C, 0xEA, 0xFF, 0xC0, 0x57, 0xE3, 0x29, 0xC6,
      0xF9, 0xC2, 0x0A, 0x80, 0x00, 0x10, 0x00, 0x02, 0x40, 0x00, 0x08, 0x00, 0x01, 0x60, 0x0E, 0x70,
      0x28, 0xE7, 0xFC, 0xEE, 0xB2, 0x6B, 0xFA, 0xFA, 0xDB, 0xF7, 0xED, 0x51, 0xCF, 0x09, 0xAC, 0x00,
      0xB6, 0x00, 0x04, 0x80, 0x00, 0x10, 0x00, 0x02, 0x40, 0x00, 0x98, 0x03, 0x1C, 0x93, 0x97, 0xD7,
      0xE7, 0xE8, 0xF9, 0xB5, 0x39, 0x43, 0x6D, 0x4E, 0x50, 0x33, 0xF6, 0x1C, 0xC1, 0x0A, 0x60, 0x0B,
      0x40, 0x00, 0x08, 0x00, 0x01, 0x20, 0x00, 0x04, 0x80, 0x39, 0xC0, 0xBE, 0xF4, 0xBE, 0xFB, 0xB1,
      0xCF, 0xB9, 0xBB, 0xDD, 0xAE, 0xE9, 0xF5, 0xD3, 0xFB, 0x11, 0xC6, 0xBE, 0xDF, 0xC0, 0x0A, 0x60,
      0x0B, 0x40, 0x00, 0x08, 0x00, 0x01, 0x20, 0x00, 0x04, 0xC0, 0xBC, 0xE6, 0x00, 0xAD, 0xEF, 0xBB,
      0x4F, 0x3F, 0x2F, 0xAF, 0xBD, 0x7E, 0xED, 0xF3, 0xFE, 0xB7, 0xCD, 0xA6, 0xF7, 0xF1, 0xAB, 0xE5,
      0xB2, 0xF7, 0xF1, 0xBB, 0xD5, 0x75, 0xF4, 0xFC, 0xF4, 0xFF, 0x6B, 0x3D, 0x27, 0xB0, 0x02, 0xD8,
      0x02, 0x10, 0x00, 0x02, 0x40, 0x00, 0x08, 0x00, 0x01, 0x30, 0xAF, 0x39, 0x40, 0x7A, 0x81, 0xDA,
      0x39, 0x3C, 0x9D, 0x23, 0xA4, 0xE7, 0xFC, 0x8B, 0xAE, 0x6B, 0xFA, 0xFC, 0xF4, 0x7E, 0x83, 0xF4,
      0xFD, 0x4B, 0xE7, 0x04, 0x56, 0x00, 0x5B, 0x00, 0x02, 0x40, 0x00, 0x08, 0x00, 0x01, 0x20, 0x00,
      0xCC, 0x01, 0x86, 0xA8, 0x9D, 0x83, 0xD3, 0x73, 0x7C, 0xEB, 0xFB, 0xFA, 0x53, 0xAB, 0x9B, 0xDB,
      0xDE, 0xC7, 0xD7, 0x8F, 0x0F, 0x4D, 0xDF, 0xBF, 0x74, 0x4E, 0x60, 0x05, 0xB0, 0x05, 0x20, 0x00,
      0x04, 0x80, 0x00, 0x10, 0x00, 0x02, 0xC0, 0x1C, 0x60, 0x88, 0x8F, 0x6D, 0x76, 0xDF, 0x7F, 0xED,
      0xF3, 0xF6, 0xDA, 0xF5, 0xD3, 0xE7, 0xA7, 0x6A, 0xE7, 0xFC, 0x54, 0xEB, 0x39, 0x88, 0x15, 0xC0,
      0x16, 0x80, 0x00, 0x10, 0x00, 0x02, 0x40, 0x00, 0x08, 0x00, 0x73, 0x80, 0xFF, 0x3C, 0xC7, 0x1F,
      0xFB, 0x9C, 0x20, 0xD5, 0xFA, 0xEF, 0xB3, 0x02, 0xD8, 0x02, 0x10, 0x00, 0x02, 0x40, 0x00, 0x08,
      0x00, 0x01, 0x60, 0x0E, 0xF0, 0x97, 0xE7, 0xD4, 0xFB, 0xF5, 0x53, 0x74, 0xFD, 0xDA, 0xF7, 0xF4,
      0x4D, 0x5D, 0xFA, 0xFE, 0xF9, 0x7E, 0x00, 0x6C, 0x01, 0x08, 0x00, 0x01, 0x20, 0x00, 0x04, 0x80,
      0x00, 0x18, 0x60, 0xF1, 0xF9, 0x5D, 0x7A, 0x7F, 0x31, 0xE0, 0xD0, 0x7F, 0x2F, 0x60, 0xEA, 0x73,
      0x82, 0xD6, 0xE7, 0x7C, 0x2B, 0x00, 0x02, 0x40, 0x00, 0x08, 0x00, 0x01, 0x20, 0x00, 0x04, 0xC0,
      0xFE, 0x1C, 0xA0, 0x94, 0xFE, 0x39, 0x40, 0xED, 0x77, 0x05, 0x6B, 0xD2, 0x73, 0x6A, 0xFA, 0xBB,
      0x86, 0xE9, 0x9C, 0x20, 0xBD, 0x9F, 0xA1, 0xA6, 0xF5, 0x39, 0xDF, 0x0A, 0x80, 0x00, 0x10, 0x00,
      0x02, 0x40, 0x00, 0x08, 0x00, 0x01, 0x30, 0x64, 0x0E, 0x30, 0xB6, 0x74, 0x0E, 0xD0, 0xFA, 0x9C,
      0x9E, 0x6A, 0x7D, 0xCE, 0xB7, 0x02, 0x20, 0x00, 0x04, 0x80, 0x00, 0x10, 0x00, 0x02, 0x40, 0x00,
      0x4C, 0x69, 0x0E, 0x90, 0xCE, 0x09, 0xA6, 0x7E, 0x4E, 0xB7, 0x02, 0x20, 0x00, 0x04, 0x80, 0x00,
      0x10, 0x00, 0x02, 0x40, 0x00, 0x98, 0x03, 0x60, 0x05, 0x40, 0x00, 0x08, 0x00, 0x01, 0x20, 0x00,
      0x04, 0x80, 0x00, 0xF8, 0x85, 0x1F, 0xA1, 0xEC, 0xA1, 0x1E, 0x7F, 0xD3, 0x9F, 0x35, 0x00, 0x00,
      0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
    };

    const int fishIonSize = sizeof(fishIconRaw) / sizeof(fishIconRaw[0]);
}

#endif // !RAWSRC

// WASTELAND:: You can find pretty handy stuffs here
// ##################################################################################################################################################################################################################
/*                                                                                                                                                                                                                   |
          _____                    _____                    _____                _____                    _____                    _____            _____                    _____                    _____          |
         /\    \                  /\    \                  /\    \              /\    \                  /\    \                  /\    \          /\    \                  /\    \                  /\    \         |
        /::\____\                /::\    \                /::\    \            /::\    \                /::\    \                /::\____\        /::\    \                /::\____\                /::\    \        |
       /:::/    /               /::::\    \              /::::\    \           \:::\    \              /::::\    \              /:::/    /       /::::\    \              /::::|   |               /::::\    \       |
      /:::/   _/___            /::::::\    \            /::::::\    \           \:::\    \            /::::::\    \            /:::/    /       /::::::\    \            /:::::|   |              /::::::\    \      |
     /:::/   /\    \          /:::/\:::\    \          /:::/\:::\    \           \:::\    \          /:::/\:::\    \          /:::/    /       /:::/\:::\    \          /::::::|   |             /:::/\:::\    \     |
    /:::/   /::\____\        /:::/__\:::\    \        /:::/__\:::\    \           \:::\    \        /:::/__\:::\    \        /:::/    /       /:::/__\:::\    \        /:::/|::|   |            /:::/  \:::\    \    |
   /:::/   /:::/    /       /::::\   \:::\    \       \:::\   \:::\    \          /::::\    \      /::::\   \:::\    \      /:::/    /       /::::\   \:::\    \      /:::/ |::|   |           /:::/    \:::\    \   |
  /:::/   /:::/   _/___    /::::::\   \:::\    \    ___\:::\   \:::\    \        /::::::\    \    /::::::\   \:::\    \    /:::/    /       /::::::\   \:::\    \    /:::/  |::|   | _____    /:::/    / \:::\    \  |
 /:::/___/:::/   /\    \  /:::/\:::\   \:::\    \  /\   \:::\   \:::\    \      /:::/\:::\    \  /:::/\:::\   \:::\    \  /:::/    /       /:::/\:::\   \:::\    \  /:::/   |::|   |/\    \  /:::/    /   \:::\ ___\ |
|:::|   /:::/   /::\____\/:::/  \:::\   \:::\____\/::\   \:::\   \:::\____\    /:::/  \:::\____\/:::/__\:::\   \:::\____\/:::/____/       /:::/  \:::\   \:::\____\/:: /    |::|   /::\____\/:::/____/     \:::|    ||
|:::|__/:::/   /:::/    /\::/    \:::\  /:::/    /\:::\   \:::\   \::/    /   /:::/    \::/    /\:::\   \:::\   \::/    /\:::\    \       \::/    \:::\  /:::/    /\::/    /|::|  /:::/    /\:::\    \     /:::|____||
 \:::\/:::/   /:::/    /  \/____/ \:::\/:::/    /  \:::\   \:::\   \/____/   /:::/    / \/____/  \:::\   \:::\   \/____/  \:::\    \       \/____/ \:::\/:::/    /  \/____/ |::| /:::/    /  \:::\    \   /:::/    / |
  \::::::/   /:::/    /            \::::::/    /    \:::\   \:::\    \      /:::/    /            \:::\   \:::\    \       \:::\    \               \::::::/    /           |::|/:::/    /    \:::\    \ /:::/    /  |
   \::::/___/:::/    /              \::::/    /      \:::\   \:::\____\    /:::/    /              \:::\   \:::\____\       \:::\    \               \::::/    /            |::::::/    /      \:::\    /:::/    /   |
    \:::\__/:::/    /               /:::/    /        \:::\  /:::/    /    \::/    /                \:::\   \::/    /        \:::\    \              /:::/    /             |:::::/    /        \:::\  /:::/    /    |
     \::::::::/    /               /:::/    /          \:::\/:::/    /      \/____/                  \:::\   \/____/          \:::\    \            /:::/    /              |::::/    /          \:::\/:::/    /     |
      \::::::/    /               /:::/    /            \::::::/    /                                 \:::\    \               \:::\    \          /:::/    /               /:::/    /            \::::::/    /      |
       \::::/    /               /:::/    /              \::::/    /                                   \:::\____\               \:::\____\        /:::/    /               /:::/    /              \::::/    /       |
        \::/____/                \::/    /                \::/    /                                     \::/    /                \::/    /        \::/    /                \::/    /                \::/____/        |
         ~~                       \/____/                  \/____/                                       \/____/                  \/____/          \/____/                  \/____/                  ~~              |
                                                                                                                                                                                                                     |
                                                                                                                                                                                                                     |
                                                                                                                                                                                                                     |
*/// ################################################################################################################################################################################################################
 //       //std::cout << z.size() << std::endl;
 //       if (z.size() > 0)
 //       {
 //           for (auto j : z)
 //           {
 //               Physics::ResolveDynamicRectVsRect(&playerBox, dt, &vRects[j.first]);
 //           }
 //       }
 //       //z.clear();


 //       //std::cout << "Number of box with collided: " << collidedBoxes.size() << std::endl;
 //       //collidedBoxes.clear();


 //       // Sort collisions in order of distance
 //       //glm::vec2 cp, cn;
 //       //float t = 0;
 //       ////std::vector<std::pair<int, float>> z;

 //       //// Work out collision point, add it to vector along with rect ID

 //       ////// Do the sort
 //       //std::sort(z.begin(), z.end(), [](const std::pair<int, float>& a, const std::pair<int, float>& b)
 //       //    {
 //       //        return a.second < b.second;
 //       //    });

 //       //// Now resolve the collision in correct order 
 //       //for (auto j : z)
 //       //    Physics::ResolveDynamicRectVsRect(&playerBox, dt, &vRects[j.first]);

 //       //// Embellish the "in contact" rectangles in yellow
 //       //for (int i = 0; i < 4; i++)
 //       //{
 //       //    if (vRects[0].contact[i])
 //       //        DrawRect(vRects[0].contact[i]->pos, vRects[0].contact[i]->size, olc::YELLOW);
 //       //    vRects[0].contact[i] = nullptr;
 //       //}


 //       /*bool collision = false;
 //
 //       for (int i = 0; i < sizeof(walls) / sizeof(walls[0]); i++) {
 //           if (Physics::AABBCheck(broadphasebox, walls[i]))
 //           {
 //               collision = true;
 //               collisiontime = Physics::SweptAABB(playerBox, walls[i], normalx, normaly);
 //               collisionTimes[i] = collisiontime;
 //               playerBox.pos.x += playerBox.vel.x * collisiontime;
 //               playerBox.pos.y += playerBox.vel.y * collisiontime;
 //               if (sgn<float>(normalx) );
 //               if (collisiontime < 1.0f)
 //               {
 //                   float remainingtime = 1.0f - collisiontime;
 //                   float dotprod = (playerBox.vel.x * normaly + playerBox.vel.y * normalx) * remainingtime;
 //                   playerBox.vel.x = dotprod * normaly;
 //                   playerBox.vel.y = dotprod * normalx;
 //                   playerBox.pos.x += playerBox.vel.x;
 //                   playerBox.pos.y += playerBox.vel.y;
 //               }

 //           }

 //       }
 //       if (collisionTimes[0] < 1.0f && collisionTimes[1] < 1.0f && collisionTimes[0] > 0.0f && collisionTimes[1] > 0.0f)
 //       {
 //           std::cout << "Collision with both walls : " << collisionTimes[0] << ", " << collisionTimes[1] << std::endl;
 //       }

 //       //playerBox.pos.x += playerBox.vel.x;
 //       //playerBox.pos.y += playerBox.vel.y;

 //       //if (Physics::AABBCheck(broadphasebox, wall_1))
 //       //{
 //       //    collisiontime = Physics::SweptAABB(playerBox, wall_1, normalx, normaly);
 //       //    playerBox.x += playerBox.vx * collisiontime;
 //       //    playerBox.y += playerBox.vy * collisiontime;
 //       //    if (collisiontime < 1.0f)
 //       //    {
 //       //        
 //       //        float remainingtime = 1.0f - collisiontime;
 //       //        float dotprod = (playerBox.vx * normaly + playerBox.vy * normalx) * remainingtime;
 //       //        playerBox.vx = dotprod * normaly;
 //       //        playerBox.vy = dotprod * normalx;
 //       //        playerBox.x += playerBox.vx;
 //       //        playerBox.y += playerBox.vy;
 //       //    }
 //       //    
 //       //}
 //       //else {
 //       //    
 //       //}

// #########################################################################################################################################################################################################
// perforamnce tuning FPS_CAP

 //FPS CAPING 1. version
        //next_game_tick += SKIP_TICKS;
        //sleep_time = next_game_tick - GetTickCount64();
        //if (sleep_time >= 0) {
        //    Sleep(sleep_time);
        //}
        //else {

        //}


        // FPS CAPING 2.version

        //while (glfwGetTime() < lasttime + 1.0 / FRAMES_PER_SECOND) {
        //    //Sleep((lasttime + 1.0 / FRAMES_PER_SECOND) - now);
        //}
        //lasttime += 1.0 / FRAMES_PER_SECOND;
        // 

//if (10000000 - long((dtbla) * 1000000000.0f) >= 0)
        //{
        //    /*std::cout << 16666666 - long((dt) * 1000000000.0f) << std::endl;*/
        //    std::this_thread::sleep_for(std::chrono::nanoseconds(10000000 - long((dtbla) * 1000000000.0f)));
        //}
        //else {
        //    //glfwSwapBuffers(window);
        //}

        // Fix your timestep
        //double newTime = glfwGetTime();
        //double frameTime = newTime - currentTime;
        //currentTime = newTime;



//fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
//glWaitSync(fence, 0, GL_TIMEOUT_IGNORED);

// #########################################################################################################################################################################################################

// AABB collision detection and resolution

        //Physics::Box tmpBox = { playerBox.pos, playerBox.size, playerBox.vel};
        //Physics::Box broadphasebox = Physics::GetSweptBroadphaseBox(tmpBox);
        //for (size_t i = 0; i < vRects.size(); i++)
        //{
        //    if (Physics::Rect_Rect(&broadphasebox, &vRects[i]))
        //    {
        //    /*if (Physics::DynamicRectVsRect(&playerBox, dt, vRects[i], cp, cn, t) && t <= 1.f)
        //    {*/
        //        // DEBUG:: std::cout << "Index of object: " << i << std::endl;
        //        Physics::ResolveDynamicRectVsRect(&playerBox, dt, &vRects[i]);
        //        collidedBoxes.push_back(i);
        //    }
        //    else
        //    {
        //        collidedBoxes.push_back(-1);
        //    }
        //}

//std::vector<std::pair<int, float>> z;


        //// first we need to sort the rectangles that's crucial !!!

        //std::sort(z.begin(), z.end(), [](const std::pair<int, float>& a, const std::pair<int, float>& b)
        //    {
        //        return a.second < b.second;
        //    });



        // Physics::ResolveDynamicRectVsRect(&playerBox, dt, &vRects[j.first]);

        //if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS)
        //{
        //    playerBox.vel += glm::normalize(ray_direction) * dt * 10000.0f;
        ////}

/*if (Physics::DynamicRectVsRect(&playerBox, dt, vRects[i], cp, cn, t) && t <= 1.f)
                {*/
                /*z.push_back({ i, t });*/



// Phisics related stuff
/*
//for (int i = 0; i < movers.size() ; i++)
        //{
        //    movers[i].update(dt);
        //    attractor.attract(&movers[i]);
        //}

        // Setting some variables in Update
        //glm::vec2 vMouse = { m_posx, m_posy };
        //glm::vec2 ray_point = { 200.f, 200.f };
        //glm::vec2 ray_direction = vMouse - playerBox.pos;
        //glm::vec2 cp, cn;
        //float t = 0;
        ////float collision = false;
        //collidedBoxes.clear();
        //z.clear();
        //playerBox.velGoal = { 0.f, 0.f };
        ////playerBox.vel = { 0.f , 0.f };

        //// Getting keyboard input
        //if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
        //{
        //    playerBox.velGoal.y -= SPEED;
        //}
        //if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
        //{
        //    playerBox.velGoal.y += SPEED;
        //}
        //if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
        //{
        //    playerBox.velGoal.x -= SPEED;
        //}
        //if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
        //{
        //    playerBox.velGoal.x += SPEED;
        //}

        //if (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS)
        //{
        //    //playerBox.vel += glm::normalize(ray_direction) * dt * 10000.0f;
        //}

        //if (glfwGetGamepadState(GLFW_JOYSTICK_1, &state))
        //{
        //    if (state.buttons[GLFW_GAMEPAD_BUTTON_DPAD_UP])
        //    {
        //        playerBox.velGoal.y -= SPEED;
        //    }
        //    if (state.buttons[GLFW_GAMEPAD_BUTTON_DPAD_DOWN])
        //    {
        //        playerBox.velGoal.y += SPEED;
        //    }
        //    if (state.buttons[GLFW_GAMEPAD_BUTTON_DPAD_LEFT])
        //    {
        //        playerBox.velGoal.x -= SPEED;
        //    }
        //    if (state.buttons[GLFW_GAMEPAD_BUTTON_DPAD_RIGHT])
        //    {
        //        playerBox.velGoal.x += SPEED;
        //    }
        //    if (state.buttons[GLFW_GAMEPAD_BUTTON_LEFT_BUMPER])
        //    {
        //        camera_zoom += (1.0 * 0.05f);


        //        if (camera_zoom <= 0.05f)
        //        {
        //            camera_zoom = 0.05f;
        //        }
        //    }
        //    if (state.buttons[GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER])
        //    {
        //        camera_zoom += (-1.0 * 0.05f);


        //        if (camera_zoom <= 0.05f)
        //        {
        //            camera_zoom = 0.05f;
        //        }
        //    }
        //    if (state.buttons[GLFW_GAMEPAD_BUTTON_START])
        //        glfwSetWindowShouldClose(window, true);

        //}

        ////playerBox.vel.x = Physics::Approach(playerBox.velGoal.x, playerBox.vel.x, dt * 800);
        ////playerBox.vel.y = Physics::Approach(playerBox.velGoal.y, playerBox.vel.y, dt * 800);
        //playerBox.vel.x = playerBox.velGoal.x * dt;
        //playerBox.vel.y = playerBox.velGoal.y * dt;

        //
        //
        //// Detecting collision and resolve it
        //// also with using Broad phase collision detection and narrow phase collision detection
        //// Technich: AABB sweeping. With Broadphasebox logic for better perfomance

        //// Sort collisions in order of distance
        //

        //// Work out collision point, add it to vector along with rect ID
        //for (size_t i = 0; i < vRects.size(); i++)
        //{
        //    if (Physics::DynamicRectVsRect(&playerBox, dt, vRects[i], cp, cn, t))
        //    {
        //        z.push_back({ i, t });
        //    }
        //}

        //// Do the sort
        //std::sort(z.begin(), z.end(), [](const std::pair<int, float>& a, const std::pair<int, float>& b)
        //    {
        //        return a.second < b.second;
        //    });
        ////
        ////
        //
        //for (std::pair<int, float> &j : z)
        //{
        //    Physics::ResolveDynamicRectVsRect(&playerBox, dt, &vRects[j.first]);
        //}

        //
        //// Updating player's position after collision resolution
        //playerBox.pos.x += playerBox.vel.x * dt;
        //playerBox.pos.y += playerBox.vel.y * dt;

        ////playerBox.vel.y += -9.81f * dt; // 1.0 == gravity


*/


// something else -- fps sleeping / caping #########################################################
/*


        //std::cout << dt << std::endl;
        //const double updateInterval = 1.0 / 60;
        //static double lastUpdate = timeGetTime();
        //double time = glfwGetTime();
        //while (time - startFrame < 1.0f / fps)
        //{
        //    //glfwSwapBuffers(window);
        //    std::this_thread::sleep_for(std::chrono::milliseconds());
        //    time = glfwGetTime();
        //}

        //std::this_thread::sleep_for(std::chrono::milliseconds(10 - int((glfwGetTime() - startFrame) * 1000)));
        //std::this_thread::sleep_for(std::chrono::milliseconds(10 - int((glfwGetTime() - startFrame) * 1000)));
        //Sleep((1000.0f / fps) - ((glfwGetTime() - startFrame)));



*/